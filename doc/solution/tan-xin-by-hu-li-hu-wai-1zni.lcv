## 方法：贪心

**思路及算法**
当出现小于前一个数的情况出现时，判断三个数的关系，逻辑分别为：
1. 当前数小于等于前两个数，此时把当前数赋值为前一个数。此时，`i++` 后，再比较的时候就是与前一个数的大小关系，相当于删除了当前数。
2. 当前数仅小于等于前一个数，大于 index 往前的第二个数，那么只需要变更前一个数为当前数即可。此时，`i++` 后，再比较的时候就是与当前数的大小关系，相当于删除了前一个数。当然，由于前一个数不会再用到，该赋值操作也可略去，代码中注释部分。

此时只需要判断这种情况是否**只出现**了一次，如果次数超过一次，直接结束循环并返回 false

**代码**

* java

```java
class Solution {
  public boolean canBeIncreasing(int[] nums) {
    int cnt = 0;
    for (int i = 1; i < nums.length && cnt <= 1; i++) {
      if (nums[i] > nums[i - 1]) continue;
      cnt++;
      if (i - 1 > 0 && nums[i] <= nums[i - 2]) {
        nums[i] = nums[i - 1];
      } //else {
        //nums[i - 1] = nums[i];
      //}
    }
    return cnt <= 1;
  }
}
```

**复杂度分析**
- 时间复杂度：O(n)
- 空间复杂度：O(1)

**结语**
如果对您有帮助，欢迎**点赞、收藏、[关注 沪里户外](/u/hu-li-hu-wai/)**，让更多的小伙伴看到，祝大家**offer多多，AC多多**！
